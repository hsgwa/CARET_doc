$$
l^{comm} = t^{msg}_{out} - t^{msg}_{in}
$$

メッセージがノードまたはコールバックの所有権に入る時刻から、出る時刻までが

# コールバックグラフについて

ROS のアプリケーションは一般的にノードのグラフで記述され、それに伴いノード単位のレイテンシ（ノードレイテンシ）を把握したいケースが生じます。
しかしながら、一つのノードにコールバックが複数存在するケースでは、ノードレイテンシを考えた際に不都合が生じます。

<!-- ![callback_graph](../imgs/callback_graph.png) -->

上図は、 /lidar と /camera トピックをサブスクライブし、その２つの情報を統合したメッセージを /fusion にパブリッシュする TargetNode を例として示しています。
/lidar のコールバックでは、メンバ変数にメッセージを格納し、/camera コールバック内で統合させています。
※ CARET では 、変数を経由したコールバック間のメッセージ渡しを Variable Passing と呼び、アーキテクチャファイルへ記述させています。

この時、 TargetNode のレイテンシは次の２つが考えられます。

- コールバック C → コールバック D（/lidar トピック → /fusion トピックのパス）
- コールバック D（/camera トピック → /fusion トピックのパス）

このような一つのノードに複数コールバックが存在ケースでは、指定するパス毎にノードレイテンシを構成するコールバックが異なります。
そのため、 CARET では ROS のアプリケーションをコールバックグラフとして記述しています。

<prettier-ignore-start>
!!! todo
        受信が完了してから送信が完了するまでの方が本当はよいかもしれない。
        ただし、今後tf対応などを行う場合にはコールバックが所有権を持っている時にした方が統一的な定義が可能。
<prettier-ignore-end>

> ノード・コールバックの整理
>
> A node is an executable that uses ROS to communicate with other nodes.  
> (<http://wiki.ros.org/ROS/Tutorials/UnderstandingNodes> より引用)
>
> と言われているように、ノードは実行可能な単位です。  
> 一方で、コールバックはスケジューリングされるタスクの単位として捉えることができます。  
> 特に ROS 2 の場合、SingleThreadedExecutor を始めとするエグゼキュータが複数存在し、  
> スレッド数の違いだけでなく、コールバックの実行順序が異なります。  
> 性能を評価する上では、何のノードが何のエグゼキュータで実行されていたかも重要な観点です。

# message context について

## callback_chain ポリシー

コールバックグラフについてもご参照ください。

### 想定

- コールバック間のキューサイズ１を想定
- 厳密に測定できるのは Single Threaded Executor のみ

### 長所

- ソースコードへの変更が不要
- 任意のメッセージ型に適用可能

### 短所

- キューサイズが大きい時、レイテンシが小さめに出るケースがある。
- multi threaded executor では、レイテンシが大きめに出るケースがある。
- 実装を読み解くのが難しい

### ノードレイテンシの定義

## ノードレイテンシの定義

## inherit_unique_stamp ポリシー

### ノードレイテンシの定義

入出力のヘッダーでマッチングを取り、入力トピックと出力トピックの時刻の差分からノードレイテンシを算出します。

#### 想定

- 入出力のタイムスタンプの値でマッチングが取れること（値を書き換えずに、そのまま publish していること）
- 入出力ともに header をもっていること

#### 長所

- ソースコードへの変更が不要
- キューサイズに依らない

#### 短所

- ヘッダーが必要
- publish 前に stamp=現在時刻としているケースは対応不可

## use_latest_message ポリシー

### ノードレイテンシの定義

## 各ポリシーの比較

## ポリシーの選び方

決定木が欲しい

## 注意点

測定できないケース
誤った値を算出するケース
